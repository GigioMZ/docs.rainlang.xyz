---
layout: single
title:  "Rain Protocol: Frontend Example"
date:   2022-02-21 14:00:23 +0000
categories: development
---

## Intro

For this tutorial, we will go through setting up a frontend example app which interacts with Rain contracts.

After this tutorial, you will be able to see how a frontend app can interact with Rain tooling.

## Setting up the Environment

We won't go into too much detail on setting up (and differences between) `npm` and `npx` or on how to code in React or using git, you can look this up yourself, but we will begin with automatically generating a basic template React app using `create-react-app`. Run `npx create-react-app --template typescript rain-frontend-example`. 

You will now have an example app which you can edit in the way you prefer. If you now run `npm start`, you should now be able to see the template app in your browser at http://localhost:3000/

Next we will install the [Ethers][ethers] library for interacting with an EVM compatible blockchain: `npm install ethers`.

### Adding the connect button

Remove all the code between the header tags (`<header className="App-header">` until `</header>`) in `App.tsx` which was autogenerated by `npx create-react-app`. 

Lets now add a button where the removed code was:

```
  <button onClick={connectWalletHandler}>
    Connect
  </button>
```

and then the `connectWalletHandler` function:

```
  const connectWalletHandler = async () => {
    // @ts-ignore
    const { ethereum } = window;

    if (!ethereum) {
      console.log("No Web3 Wallet installed");
    }

    try {
      const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
      console.log(`Address ${accounts[0]} connected`);
      setCurrentAccount(accounts[0]);
    } catch (err) {
      console.log(err);
    }
  }
```

(we have added @ts-ignore for now instead of defining typings for the `window` object). Finally add the state hook:

```
  const [currentAccount, setCurrentAccount] = useState(null);
```

and the import:

```
  import React, {useState} from 'react';
```

## Networks

We now want to add the network and smart contract addresses. We will be using Matic Mumbai Testnet so you will need to [get some test MATIC][matic-faucet] as well as set up your Web3 wallet to [include details of the Matic network][matic-setup].

Create and save a file called `networks.ts`:

```
export const networks = [{
  label: "Mumbai",
  config: {
    chainId: '0x13881',
    chainName: 'Mumbai',
    rpcUrls: ['https://rpc-mumbai.maticvigil.com'],
    nativeCurrency: {
      name: 'MATIC',
      symbol: 'MATIC', // 2-6 characters long
      decimals: 18
    },
    blockExplorerUrls: ['https://mumbai.polygonscan.com/']
  },
  addresses: {
    BALANCE_TIER_FACTORY_ADDRESS:
      "0x31a5F2f477297C2F3AED28E03Fec8934cc4298a7",
    ERC721_BALANCE_TIER_FACTORY_ADDRESS:
      "0xF95c6106d8b0FE566805a856Dfb7F64083369caF",
    COMBINE_TIER_FACTORY_ADDRESS:
      "0x09f91AC0215AFa0533Bf3212FBe59086300c3165",
    SALE_FACTORY: "0x7fbc27F1D14e0c59e2F4346B5166692659c4694D",
    EMISSIONS_FACTORY: "0x83b45E84dfd5f00a03c6C483B27C44A0C4E9903f",
    GATED_NFT_FACTORY: "0xD9AD3A87E4c1F604091c1A0E147c88B3A9E1B4ad",
    VERIFY_TIER_FACTORY: "0x007aB50f8c491AE54114139b9ada40aB3c6e4811",
    VERIFY_FACTORY: "0x39e3c764e6185C6a3100D0dA1195D26519b42750"
  },
  blockExplorer: 'https://mumbai.polygonscan.com/',
  graphUrl: 'https://api.thegraph.com/subgraphs/name/beehive-innovation/rain-protocol-v2_1-mumbai'
}]
```

We then want to import this file in our `App.tsx`:

`import { networks } from "./networks";`

and change the connection line to include the `chainId`:

```
  const accounts = await ethereum.request({
    method: 'eth_requestAccounts',
    chainId: networks[0].config.chainId,
  });
```


Your application should now connect when you click `connect` (make sure you have switched to Matic in your Web3 wallet). Please note that this is a very basic way of connecting to the page with a Web3 wallet, it is better to look at a project such as [Web3 React][web3-react] for more advanced ways to do this. You may also need to close and reopen your browser so that you are asked to sign in to to your Web3 Wallet again (chose the network which you set up from the [previous link][web3-connect]).

## Calling a contract

We will now call a contract with an opcodes example. We won't go into too much detail here on what is happening in the opcodes (see the [opcodes guides section][opcodes-guides]) for more details.

This opcodes example will check if an arbitrary block number is before or after the current block number:

Save this code to a new file `opcodeExample.ts`:

```
import { concat } from "ethers/lib/utils";
import { op } from "./utils";

export const enum Opcode {
  VAL,
  BLOCK_NUMBER,
  GREATER_THAN,
}

export const isAfterBlockNumber = (blockNumber: number) => {
  return {
    sources: [
      concat([
        op(Opcode.BLOCK_NUMBER),
        op(Opcode.VAL, 0),
        op(Opcode.GREATER_THAN),
      ]),
    ],
    constants: [blockNumber - 1],
    stackLength: 3,
    argumentsLength: 0,
  };
};
```

Add the import to `App.tsx`: `import { isAfterBlockNumber } from "./opcodeExample";`

We also need to create a stripped back version of `utils.ts` (which will eventually come bundled with our SDK):

```
import { concat, Hexable, hexlify, zeroPad } from "ethers/lib/utils";
import type { BytesLike } from "ethers";

/**
 * Converts an opcode and operand to bytes, and returns their concatenation.
 * @param code - the opcode
 * @param erand - the operand, currently limited to 1 byte (defaults to 0)
 */
export function op(code: number, erand = 0): Uint8Array {
  return concat([bytify(code), bytify(erand)]);
}

/**
 * Converts a value to raw bytes representation. Assumes `value` is less than or equal to 1 byte, unless a desired `bytesLength` is specified.
 *
 * @param value - value to convert to raw bytes format
 * @param bytesLength - (defaults to 1) number of bytes to left pad if `value` doesn't completely fill the desired amount of memory. Will throw `InvalidArgument` error if value already exceeds bytes length.
 * @returns {Uint8Array} - raw bytes representation
 */
export function bytify(
  value: number | BytesLike | Hexable,
  bytesLength = 1
): BytesLike {
  return zeroPad(hexlify(value), bytesLength);
}
```

## Linking it all up

Let us link everything up. We will now create a second button for calling the Smart Contract Backend:

```
<button onClick={runOpcodesExample}>
  Run Opcodes Example
</button>
```

And finally we will create the function which is called when the button is pressed:

```
  const runOpcodesExample = async () => {
  
  
  
```


[//]: # (todo what is the best way to get the abi in or are we using typechain)
[//]: # (todo does josh use own connect button or a library?)

[discord]: https://discord.gg/dzYS3JSwDP
[ethers]: https://docs.ethers.io/
[hardhat]: https://hardhat.org/getting-started/

[//]: # (todo link here)
[previous-tutorial]: https://blog.rainprotocol.xyz
[web3-connect]: https://www.web3.university/article/how-to-build-a-react-dapp-with-hardhat-and-metamask
[web3-react]: https://github.com/NoahZinsmeister/web3-react
[matic-faucet]: https://faucet.polygon.technology/
[matic-setup]: https://medium.com/stakingbits/setting-up-metamask-for-polygon-matic-network-838058f6d844
[opcodes-guides]: https://docs.rainprotocol.xyz/guides/Opcodes/running-an-opcodes-example